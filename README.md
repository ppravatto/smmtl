# smmtl
The simple matrix manipulation template library (SMMTL) is a header-only C++ library implementing simple template definitions of matrix and vector objects.

### Requirements
The use of the library requires a compiler capable of adopting the C++11 standard. 

The variable type adopted in the template specialization, hereafter indicated with `mytype`, must implement a definition of the basic set of operators (`+`,`-`,`+=`,`+=`, `*`, `<<`) and must provide a definition of the `abs` and `pow` functions. Furthermore, the selected variable type should provide a way to explicitly cast the `0.` double value according to `mytype(0.)`.

## The `Mat` class
The `Mat` class implements the basic functionality of a matrix object. The class supports both square and rectangular matrices. Element-wise sum and subtraction are invoked using the standard operators `+`, `-`, `+=` and `-=`. The matrix product (multiplication of row by columns) between `Mat` objects or between `Mat` and `Vec` objects can be invoked using the operator `*`. The product of the matrix by a scalar value is also invoked using the `*` operator. The element-wise product is not implemented at the moment.

The matrix elements can be read and modified using the `()` operator by listing the row and column of the wanted element according to `(row, col)`. The transposed of the matrix can be obtained by calling the `.t()` member function. If the user wants to transpose the object itself, the `.transpose()` method (`void` return) can be called.

The `Mat` class implements the `is_square()` function (`bool` return) that returns `true` when the matrix is squared or `false` otherwise. The class also implements the `trace()` function that, as the name implies, returns the trace of the matrix (only for square matrices).

#### Constructors
The user can initialize explicitly a matrix object specifying the number of rows and columns and a list of values ordered by rows:
```
Mat<mytype>(int nrows, int ncols)
Mat<mytype>(int nrows, int ncols, <mytype>* list)
```
If no list is provided all the elements will be initialized to the zero value according to the casting operation `mytype(0.)`.

The class provides also a non-parametrized default constructor `Mat<mytype>()` that return non-initialized matrix objects. These can be initialized at a later time by using the provided copy assignment operator. An operation performed on non-initialized objects will result in an `InitError` exception.

## The `Vec` class
The syntax and structure of the `Vec` class is essentially equivalent to the one described for the `Mat` class.

Element-wise sum and subtraction are invoked using the standard operators `+`, `-`, `+=` and `-=`. The "matrix" product (multiplication of row by columns) between `Mat` and `Vec` objects or between `Vec` objects can be invoked using the operator `*`. Please notice how the scalar product between two vectors returns a variable of type `mytype`. The product of the vector by a scalar value is also invoked using the `*` operator. Also in this case, the element-wise product is, at the moment, not implemented.

The vector elements can be read and modified using the `()` operator by indicating the index of the wanted element according to `(index)`. The transposed vector can be obtained by calling the `.t()` member function. If the user wants to transpose the object itself, the `.transpose()` method (`void` return) can be called.

The vector class can represent both column and row vectors. By default, the vector is initialized as a column vector but a row vector can be generated by invoking either the `t()` of `transpose()` functions. In order to verify the type of shape the `Vec` class implements the `is_column()` function that returns `true` if the vector is a column one or `false` otherwise. 

The class also implements the `p_norm(double p)` function that computes the $p$-norm of the vector defined according to the equation:
$$ ||\mathbf{x}||_p := \sqrt[p]{\sum_i |x_i|^p}$$
The function `norm()` is also implemented and returns the euclidean norm of the vector ($p$-norm with $p=2$).

## Exceptions
The `smmtl.h` header file defines also a set of custom exceptions. These are defined in the `smmtl::exceptions` namespace. A complete list of exceptions is provided in the following table:

| Exception | Message | Description |
| --------- | ------- | ------------|
| `BoundError` | `"Index out of bounds"` | The exception is thrown whenever an invalid element index is called |
| `InitError` | `"Operation performed on uninitialized object"` | The exception is thrown whenever an operation is performed on a non-initialized object (e.g. object created with non-parametrized constructors) |
| `ShapeError` | `""Mismatch between the objects shape"` | The exception is thrown whenever a mismatch between expected shape values is encountered (e.g. product between matrices of non-compatible shapes) |
| `OperationError` | `"The called function cannot be applied to the given object"` | The exception is thrown whenever a defined operation is called improperly (e.g. calling the trace function for a rectangular matrix) |
| `ValueError` | `"Invalid parameter value encountered"` | The exception is thrown whenever a parameter assumes an invalid value (e.g. setting a negative or null integer as the matrix number of row or columns) |

## Example
The use of the SMMTL library is very simple. In what follows a sample code implementing a matrix-vector product is presented:

```
#include <iostream>
#include "smmtl.h"

int main(){

    double list_A[4] = {1., 2., 3., 4.};
    smmtl::Mat<double> A(2, 2, list_A);

    smmtl::Vec<double> v(2);
    v(0) = 1.;
    v(1) = -2.5;

    smmtl::Vec<double> w = A*v;

    std::cout << w.t();

    return 0;
}
```
The code can be compiled, using the GNU g++ compiler, using the command:
```
g++ -std=c++11 example.cpp -o example.x -I<location>
```
where `<location>` must represent the path to the folder containing the `smmtl.h` header file. When `example.x` is executed, the following output should be observed:
```
-4  -7
```